# Cursor勉強会 詳細スライド（50枚）

---
marp: true
theme: default
paginate: true
---

# Cursorで実現する次世代の開発体験

## AIペアプログラミングで開発効率を劇的に向上

2025年1月
発表者名

<!--
説明者メモ：
- 最初のスライドでは、参加者の期待値を高めることが重要
- Cursorがもたらす「体験の変化」を強調
- 単なるツールではなく、開発手法の変革であることを伝える
-->

---

# 本日のゴール

## 🎯 3つの達成目標

1. **Cursorの主要機能をマスターする**
   - Tab補完、Ctrl+K、チャット機能の使いこなし

2. **AIペアプログラミングを体験する**
   - 自然言語での開発フローを理解

3. **開発効率を2倍にする方法を学ぶ**
   - 実践的なTipsとベストプラクティス

<!--
説明者メモ：
- 具体的な目標を提示して、参加者の学習意欲を高める
- 「2倍」という数字は実際の事例に基づく
- ハンズオンがある場合は、ここで言及
-->

---

# アジェンダ

## 📋 本日の流れ（50分）

| 時間 | セクション | 内容 |
|------|-----------|------|
| 5分 | イントロ | Cursorとは何か |
| 10分 | 基本概要 | 特徴と活用事例 |
| 15分 | 主要機能 | 実践的な使い方 |
| 10分 | 新機能 | Cursor 1.0の革新 |
| 10分 | Q&A | 質問と実演 |

<!--
説明者メモ：
- 時間配分は目安。質問が多い場合は柔軟に対応
- 各セクションの重要ポイントを事前に確認
- デモの準備を忘れずに
-->

---

# なぜ今Cursorなのか

## 🚀 開発現場の課題を解決

### **75%** のコーディング時間削減
- ボイラープレートの自動生成
- リファクタリングの高速化

### **グラントワーク**からの解放
- 単純作業はAIに任せる
- クリエイティブな設計に集中

### **思考の速度**で実装が可能に
- アイデアを即座にコードへ
- プロトタイピングの高速化

<!--
説明者メモ：
- 実際の導入企業の事例を交えると説得力が増す
- 「グラントワーク」＝単調で繰り返しの多い作業
- 参加者の共感を得られるような例を挙げる
-->

---

# 従来の開発 vs Cursor開発

## 🔄 開発フローの変革

### Before（従来の開発）
```
手動でコード作成 → デバッグ → 修正 → テスト
    ↑                              ↓
    └──────── 繰り返し ────────────┘
```

### After（Cursor開発）
```
自然言語で指示 → AI生成 → レビュー → 完成
       ↓                      ↑
    フィードバック ──────────┘
```

<!--
説明者メモ：
- 図を使って視覚的に違いを示す
- 実際のコーディング時間の比較データがあれば追加
- AIは「置き換え」ではなく「協働」であることを強調
-->

---

# CursorはAIファーストなIDE

## 🧠 3つの革新的アプローチ

### 1. **VS Codeベース**で学習コストゼロ
- 既存の拡張機能がそのまま使える
- 慣れ親しんだUIとショートカット

### 2. **プロジェクト全体**を理解するAI
- ファイル間の依存関係を把握
- コンテキストを考慮した提案

### 3. **自然言語**での開発が可能
- 「この機能を実装して」で動作
- 技術的な指示も日常語でOK

<!--
説明者メモ：
- VS Codeユーザーが多い場合は、移行の簡単さを強調
- AIの「理解力」について具体例を示すと効果的
- デモでは実際に自然言語で指示を出してみる
-->

---

# 3つの革新的な特徴

## 💡 Cursorの強み

### 1. **コードベース全体の理解**
- 数千ファイルのプロジェクトも瞬時に把握
- importや参照関係を自動で追跡

### 2. **複数ファイルの同時編集**
- 関連ファイルを一括で更新
- リファクタリングが劇的に効率化

### 3. **自律的なタスク実行**
- テスト作成から実行まで自動化
- エラー修正も自動で試行

<!--
説明者メモ：
- それぞれの特徴について、実際の使用場面を説明
- 大規模プロジェクトでの効果を強調
- 「自律的」＝人の介入なしに動作する点を説明
-->

---

# Cursorの立ち位置

## 🎯 AI開発ツールの比較

| ツール | 特徴 | 最適な用途 |
|--------|------|-----------|
| **GitHub Copilot** | 補完特化 | 単一ファイルの編集 |
| **Cursor** | 統合開発環境 | プロジェクト全体の開発 |
| **Devin** | 完全自律型 | 独立したタスク実行 |
| **Claude Code** | 対話型 | コードの説明・相談 |

### 📌 Cursorは「統合環境」として最もバランスが良い

<!--
説明者メモ：
- 各ツールの違いを明確に説明
- Cursorが「ちょうどいい」立ち位置であることを強調
- 他ツールとの併用も可能であることを補足
-->

---

# 活用事例1: UI開発の自動化

## 🎨 Netflix風アプリを30分で実装

### 実装内容
- **コンポーネント自動生成**
  - ヘッダー、カード、カルーセルなど
- **スタイリングも同時に完成**
  - レスポンシブデザイン対応
- **状態管理も含めて実装**
  - お気に入り機能、履歴機能

### 💬 実際の指示例
```
「Netflixのようなビデオストリーミングアプリの
ホーム画面を作って。カルーセル表示で、
ホバー時にプレビュー再生する機能も追加して」
```

<!--
説明者メモ：
- 実際のデモがあると効果的
- 30分という時間は目安（スキルによって前後する）
- 生成されたコードの品質についても言及
-->

---

# 活用事例2: 機能追加の効率化

## 🌓 ダークモード実装が5分で完了

### 実装プロセス
1. **関連ファイルを自動で特定**
   - CSS、コンポーネント、設定ファイル
2. **一括で変更を適用**
   - カラーパレットの切り替え
   - アイコンの変更
3. **テストコードも同時生成**
   - 切り替え機能のテスト
   - ビジュアルリグレッションテスト

### 🔍 従来なら2-3時間かかる作業

<!--
説明者メモ：
- ダークモードは多くの開発者が経験する機能
- 「5分」は理想的な条件での時間
- 複雑なプロジェクトでは追加の調整が必要な場合も
-->

---

# 活用事例3: バグ修正の高速化

## 🐛 エラーの原因を即座に特定

### Cursorのバグ修正フロー

1. **エラーメッセージを解析**
   ```
   TypeError: Cannot read property 'map' of undefined
   ```

2. **原因と修正案を複数提示**
   - 「配列の初期化忘れ」
   - 「非同期処理の待機漏れ」
   - 「型定義の不整合」

3. **影響範囲も自動チェック**
   - 関連するテストの実行
   - 依存コンポーネントの確認

<!--
説明者メモ：
- よくあるエラーを例に使うと共感を得やすい
- 修正案が複数出ることで、学習にもなる点を強調
- デバッグ時間の短縮効果を数値で示すと良い
-->

---

# 導入企業の声

## 📊 実際の効果測定結果

### 開発速度が**2.5倍**に向上
- コード生成の自動化
- レビュー時間の短縮

### ジュニアエンジニアの成長が加速
- AIからベストプラクティスを学習
- コードレビューの質が向上

### コードレビュー時間が**半減**
- 明らかなバグはAIが事前に指摘
- レビュアーは設計に集中できる

<!--
説明者メモ：
- 具体的な企業名があれば追加（許可がある場合）
- 数値は平均値であり、プロジェクトによって異なることを補足
- ROIの観点からも説明できると経営層にも響く
-->

---

# Cursorの料金プラン

## 💰 投資対効果の高い価格設定

| プラン | 料金 | 特徴 | おすすめ |
|--------|------|------|----------|
| **Free** | $0 | 基本機能<br>2週間の試用 | お試し |
| **Pro** | $20/月 | 無制限利用<br>高速モデル | 個人開発者 |
| **Business** | 要相談 | チーム機能<br>管理機能 | 企業 |

### 📌 Pro版は開発者1日分の人件費以下

<!--
説明者メモ：
- ROIを強調（1日分の人件費で1ヶ月使える）
- 無料試用期間で十分に効果を実感できることを伝える
- チーム導入の場合はボリュームディスカウントもある
-->

---

# Privacy Modeで安心開発

## 🔒 機密プロジェクトにも対応

### Privacy Modeとは
**コードがクラウドに送信されない**ローカル処理モード

### 主な特徴
- **ローカル処理**でコード流出防止
- **機密プロジェクト**に最適
- **ゼロトラスト**アーキテクチャ

### 利用シーン
- 金融系システム開発
- 政府系プロジェクト
- 未発表の新機能開発

<!--
説明者メモ：
- セキュリティを重視する企業には必須の機能
- パフォーマンスは若干低下するが、安全性を優先
- 通常モードとの切り替えは簡単
-->

---

# 最適なAIモデルの選び方

## 🤖 用途別モデル選択ガイド

| モデル | 特徴 | 最適な用途 | 速度 |
|--------|------|-----------|------|
| **GPT-4o** | 汎用的で高性能 | 複雑なロジック | ★★★ |
| **Claude 3.5 Sonnet** | コード理解に優秀 | リファクタリング | ★★★★ |
| **Gemini 2.0 Pro** | 最新技術対応 | 最新フレームワーク | ★★★★★ |
| **GPT-3.5** | 高速レスポンス | 単純なタスク | ★★★★★ |

### 💡 プロジェクトに応じて切り替えが可能

<!--
説明者メモ：
- モデルの切り替えは設定から簡単に可能
- 料金プランによって使えるモデルが異なる
- 用途に応じた使い分けが重要
-->

---

# Tab補完の革新性

## ⚡ 次世代のコード補完機能

### 従来の補完との違い

**従来**: 単語レベルの補完
```python
user.get_  # → get_name(), get_email()
```

**Cursor**: 文脈を理解した複数行補完
```python
# ユーザーの情報を整形して返す関数
def format_user_info(user):
    # → 以下が自動生成
    return {
        'full_name': f"{user.first_name} {user.last_name}",
        'email': user.email.lower(),
        'created': user.created_at.strftime('%Y-%m-%d')
    }
```

<!--
説明者メモ：
- 灰色のゴーストテキストで表示される
- Tabキーで採用、Escでキャンセル
- AIがプロジェクト全体のコードスタイルを学習
-->

---

# Tab補完の実例

## 📝 実践的な使用例

### 1. **関数の引数を自動修正**
```python
# 古い: process_data(data)
# 新しい: process_data(data, config)
# → 呼び出し箇所も自動で更新
```

### 2. **変数名の一括リネーム**
```javascript
// userId → customerId
// 関連する全ての箇所が自動変更
```

### 3. **importの自動追加**
```typescript
const result = processUser(userData)
// → import { processUser } from './userUtils' が自動追加
```

<!--
説明者メモ：
- 実際にデモで見せると効果的
- プロジェクトの規模が大きいほど効果を実感
- 間違った提案は簡単に却下できることも説明
-->

---

# Tab補完の活用テクニック

## 🎮 効率を最大化する操作方法

### キーボードショートカット

| 操作 | 効果 | 使用場面 |
|------|------|----------|
| **Tab** | 補完を採用 | 提案が正しい時 |
| **Tab連打** | 連鎖的な編集 | 関連箇所の一括修正 |
| **Ctrl+→** | 単語単位の採用 | 部分的に採用したい時 |
| **Esc** | キャンセル | 提案が不要な時 |

### 💡 Pro Tips
- コメントを書いてから関数を生成
- 変数名を明確にすると精度UP

<!--
説明者メモ：
- Tab連打は特に強力な機能
- 慣れると手放せなくなる機能であることを強調
- ライブデモがあると理解しやすい
-->

---

# Ctrl+K: インライン編集の威力

## ✏️ エディタ内で直接AI指示

### Ctrl+Kとは
**選択したコードに対して自然言語で変更指示**を出せる機能

### 使用方法
1. コードを選択
2. `Ctrl+K`（Mac: `Cmd+K`）
3. 指示を入力
4. Enterで実行

### 特徴
- エディタから離れずに作業継続
- 複雑な変更も一発で実行
- 元に戻すのも簡単（Ctrl+Z）

<!--
説明者メモ：
- チャット機能との使い分けを説明
- 小規模な変更に最適
- フローを中断しないのが最大のメリット
-->

---

# Ctrl+Kの実践例

## 🔧 よく使う指示パターン

### パフォーマンス最適化
```
「この関数を高速化して」
「メモ化を使って最適化」
「不要な再レンダリングを防ぐ」
```

### 言語・形式の変換
```
「TypeScriptに変換して」
「async/awaitに書き換えて」
「関数型スタイルに変更」
```

### エラーハンドリング
```
「エラーハンドリングを追加」
「try-catchで囲んで」
「適切なエラーメッセージを追加」
```

<!--
説明者メモ：
- 具体的な指示ほど良い結果が得られる
- 複雑な変更は段階的に行うのがコツ
- 生成されたコードは必ずレビューすることを強調
-->

---

# Ctrl+Kの応用

## 🚀 ターミナルでも使える

### ターミナルでのCtrl+K
```bash
# 「すべてのログファイルを圧縮して古いものを削除」
# → 複雑なコマンドを自然言語で生成

find . -name "*.log" -mtime +30 -exec gzip {} \; -delete
```

### Git操作の簡略化
```bash
# 「先週からの自分のコミットを表示」
git log --author="$(git config user.name)" --since="1 week ago"
```

### 💡 複雑なコマンドを覚える必要なし

<!--
説明者メモ：
- ターミナル操作が苦手な人にも優しい
- 危険なコマンドは実行前に確認
- シェルスクリプトの生成にも使える
-->

---

# チャット機能（Cmd+L）の特徴

## 💬 プロジェクト全体を理解する対話型AI

### チャット機能の強み

1. **プロジェクト全体を把握**
   - 全ファイルの内容を理解
   - 依存関係を考慮した回答

2. **コードの意図を説明**
   - 「この関数は何をしている？」
   - アーキテクチャの説明も可能

3. **バグの原因を分析**
   - エラーログから原因特定
   - 修正方法の提案

<!--
説明者メモ：
- Ctrl+Kとの使い分け：大きな変更や相談はチャット
- コンテキストウィンドウが大きいので、長い会話も可能
- @シンボルと組み合わせると更に強力
-->

---

# チャットの効果的な使い方

## 🎯 質問パターンと回答例

### コード理解
```
Q: 「この関数の目的は？」
A: 「ユーザー認証を行い、JWTトークンを生成します。
   成功時はトークンを、失敗時はエラーを返します。」
```

### 改善提案
```
Q: 「パフォーマンスを改善する方法は？」
A: 「1. キャッシュの導入
    2. データベースクエリの最適化
    3. 非同期処理の活用」
```

### セキュリティ診断
```
Q: 「セキュリティの問題はある？」
A: 「SQLインジェクションの脆弱性があります。
   パラメータ化クエリを使用してください。」
```

<!--
説明者メモ：
- 具体的な質問ほど有用な回答が得られる
- コードを選択してから質問すると、より正確
- 複数の観点から質問すると理解が深まる
-->

---

# @シンボルでコンテキスト管理

## 📎 AIに正確な文脈を提供

### @シンボルの種類

| シンボル | 用途 | 例 |
|----------|------|-----|
| **@ファイル** | 特定ファイル参照 | @components/Header.tsx |
| **@フォルダ** | ディレクトリ全体 | @src/utils |
| **@Web** | 最新情報を検索 | @Web React 19の新機能 |
| **@Docs** | ドキュメント参照 | @Docs AWS SDK |
| **@Git** | Git履歴を参照 | @Git 最近の変更 |

### 💡 複数の@シンボルを組み合わせ可能

<!--
説明者メモ：
- @シンボルなしだと、AIが推測で答える可能性
- 正確な情報源を指定することで精度向上
- プロジェクトが大きいほど重要な機能
-->

---

# @シンボルの実践例

## 🔍 具体的な使用シーン

### 依存関係の更新
```
@package.json このファイルの依存関係を最新の安定版に更新して。
破壊的変更がある場合は教えて。
```

### プロジェクト全体のリファクタリング
```
@src すべてのコンポーネントでPropTypesを
TypeScriptの型定義に置き換えて
```

### 最新技術の実装
```
@Web Next.js 14のServer Actionsを使って
このフォームを書き換えて
```

<!--
説明者メモ：
- @シンボルの後にスペースを入れることを忘れずに
- オートコンプリートが効くので、パスは簡単に入力可能
- 複雑なタスクほど@シンボルの価値が高まる
-->

---

# Composerモード

## 🎼 複数ファイルの同時編集

### Composerモードとは
**複数のファイルを同時に編集・プレビューできる**強力な機能

### 主な特徴
- **並列プレビュー**: 変更内容を一覧表示
- **一括確認**: すべての変更を確認してから適用
- **ロールバック**: 簡単に元に戻せる

### 起動方法
- `Ctrl+I`（Mac: `Cmd+I`）
- または「Composer」ボタンをクリック

<!--
説明者メモ：
- 大規模な変更時に特に有用
- プレビューで確認してから適用できるので安全
- Agentモードとの違いも説明すると良い
-->

---

# Composerの活用シーン

## 🛠️ 効果的な使用例

### 1. **大規模リファクタリング**
- クラスコンポーネント → 関数コンポーネント
- コード規約の一括適用
- ディレクトリ構造の変更

### 2. **新機能の実装**
- API + フロントエンド + テスト
- 複数のコンポーネントにまたがる機能
- 状態管理の追加

### 3. **アーキテクチャ変更**
- モノリス → マイクロサービス
- REST → GraphQL
- 同期処理 → 非同期処理

<!--
説明者メモ：
- 実際のプロジェクトでの使用例を紹介
- 変更の規模が大きいほど価値が高い
- チーム開発でも影響範囲が明確になる利点
-->

---

# Custom Modeでワークフロー最適化

## ⚙️ 自分好みにカスタマイズ

### Custom Modeとは
**個人やチームの開発スタイルに合わせてCursorをカスタマイズ**する機能

### カスタマイズ可能な項目
1. **独自のショートカット設定**
   - よく使う操作をワンキーで実行
   
2. **AIの振る舞いをカスタマイズ**
   - 応答スタイルの調整
   - 優先する提案の種類

3. **チーム専用モードの作成**
   - 共通の設定を共有
   - プロジェクト固有のルール

<!--
説明者メモ：
- 設定ファイルはJSONで管理
- チームで共有するとオンボーディングが楽
- 徐々にカスタマイズしていくのがおすすめ
-->

---

# Cursor Rulesの3層構造

## 📋 ルールの優先順位と管理

### ルールの階層

```
1. Rules Type（最優先）
   ↓
2. Project Rules（プロジェクト固有）
   ↓  
3. User Rules（個人設定）
```

### 各ルールの特徴

| レベル | 場所 | 用途 | 共有 |
|--------|------|------|------|
| **User** | ~/.cursor/rules | 個人の好み | × |
| **Project** | .cursor/rules | プロジェクト規約 | ○ |
| **Type** | 設定で指定 | 言語・FW別 | △ |

<!--
説明者メモ：
- 優先順位を理解することが重要
- プロジェクトルールはGitで管理可能
- チーム開発では統一性が保てる
-->

---

# Agent機能（Ctrl+I）の概要

## 🤖 複雑なタスクを自律的に実行

### Agentとは
**自然言語の指示から、複数のステップを自動で実行**するAI機能

### 主な特徴
1. **複雑なタスクを自律実行**
   - 必要なファイルを自動判断
   - 順序立てて実装

2. **ファイル作成から実装まで**
   - ディレクトリ構造も含めて生成
   - 設定ファイルも自動作成

3. **テスト実行も自動化**
   - テストコードの生成
   - 実行して結果確認

<!--
説明者メモ：
- Composerとの違い：より自律的で高度
- 大きなタスクに最適
- 途中で介入も可能
-->

---

# Agentの実行例

## 🚀 実際の使用シーン

### 「認証機能を実装して」という指示で...

1. **必要なファイルを自動作成**
   ```
   /auth
     ├── login.tsx
     ├── register.tsx
     ├── authContext.tsx
     └── authAPI.ts
   ```

2. **APIとフロントエンドを同時開発**
   - バックエンドのエンドポイント
   - フロントエンドのフォーム
   - 状態管理の実装

3. **セキュリティも考慮**
   - パスワードのハッシュ化
   - JWTトークンの実装

<!--
説明者メモ：
- 実際の実行には数分かかる
- 進行状況が表示されるので安心
- 生成されたコードは必ずレビュー
-->

---

# YOLOモードの威力

## 🎲 自動修正モード

### YOLOモードとは
**「You Only Live Once」- テストが通るまで自動で修正を繰り返す**モード

### 動作フロー
```
1. コード生成
   ↓
2. テスト実行
   ↓
3. 失敗したら自動修正
   ↓
4. 成功するまで繰り返し
```

### 使用上の注意
- 無限ループに注意
- 重要な変更は手動確認
- CI/CD環境では慎重に

<!--
説明者メモ：
- 「YOLO」は少し危険そうな名前だが、実際は安全機能あり
- 回数制限があるので無限ループしない
- デモでは簡単な例から始める
-->

---

# BugBotでPRを自動レビュー

## 🐞 AIによるコードレビュー

### BugBotの機能
1. **潜在的バグを事前発見**
   - Null参照の可能性
   - 型の不整合
   - ロジックエラー

2. **セキュリティ問題も指摘**
   - SQLインジェクション
   - XSS脆弱性
   - 認証・認可の問題

3. **修正案も提示**
   - 具体的なコード例
   - ベストプラクティス
   - 参考リンク

<!--
説明者メモ：
- 人間のレビュアーの負担を大幅に軽減
- 見逃しがちな問題も検出
- False Positiveもあるので最終判断は人間
-->

---

# BugBotの活用方法

## 🔧 効果的な運用方法

### セットアップ
1. **GitHub連携で自動起動**
   - PRを作成すると自動実行
   - Webhookで連携

2. **「Fix in Cursor」で即修正**
   - ワンクリックでCursorが開く
   - 該当箇所にジャンプ

3. **レビュー時間を90%削減**
   - 明らかな問題は事前に解決
   - レビュアーは設計に集中

### 💡 チーム全体の品質向上に貢献

<!--
説明者メモ：
- 導入は簡単（GitHubアプリをインストール）
- 無料プランでも使用可能
- カスタムルールも設定可能
-->

---

# バックグラウンドエージェント

## ⚡ 非同期タスク実行

### バックグラウンドエージェントとは
**メインの作業を妨げずに、長時間タスクを実行**する機能

### 特徴
- **非同期でタスク実行**
  - 開発を続けながら実行
  - 完了通知あり

- **メイン作業を妨げない**
  - CPUリソースを調整
  - 優先度設定可能

- **長時間タスクに最適**
  - 大規模リファクタリング
  - 全体テストの実行

<!--
説明者メモ：
- クラウド実行なので、ローカルPCの負荷なし
- 料金プランによって同時実行数が異なる
- 進捗はリアルタイムで確認可能
-->

---

# バックグラウンドの使用例

## 📊 実践的な活用シーン

### 1. **大規模テストの実行**
```
「全てのテストを実行して、
失敗したものだけレポートして」
```

### 2. **ドキュメント自動生成**
```
「全ての公開APIに対してOpenAPI仕様書を生成し、
READMEも更新して」
```

### 3. **データベースマイグレーション**
```
「開発環境のDBスキーマを本番環境に合わせて、
必要なマイグレーションファイルを生成」
```

<!--
説明者メモ：
- バックグラウンドタスクは履歴が残る
- 失敗した場合は通知が来る
- 定期実行の設定も可能（今後のアップデート）
-->

---

# メモリー機能（ベータ）

## 🧠 プロジェクトの知識を蓄積

### メモリー機能とは
**プロジェクト固有の情報をAIが記憶し、次回以降の開発に活用**

### 記憶される情報
1. **プロジェクト固有の知識**
   - ビジネスロジック
   - 独自の用語集
   - アーキテクチャ決定

2. **チーム間で知識共有**
   - コーディング規約
   - よくある質問と回答
   - トラブルシューティング

3. **学習曲線の短縮**
   - 新メンバーのオンボーディング
   - 過去の決定事項の参照

<!--
説明者メモ：
- ベータ版なので、今後改善される予定
- プライバシーモードでは使用不可
- チームでの知識共有に革命を起こす可能性
-->

---

# メモリーの実践活用

## 💾 効果的な使い方

### 記憶させるべき情報

```
「このプロジェクトでは、
- 全てのAPIはRESTfulに設計する
- エラーレスポンスはRFC7807形式
- 日時は全てUTCで扱う
ことを覚えておいて」
```

### 活用例
- **コーディング規約を記憶**
  - 命名規則、インデント等

- **APIの使い方を保存**
  - 社内APIの仕様
  - 認証方法

- **よくあるバグパターンを学習**
  - 過去の失敗から学ぶ

<!--
説明者メモ：
- 明示的に「覚えて」と指示する必要あり
- 記憶した内容は管理画面で確認可能
- 不要な記憶は削除も可能
-->

---

# 今後のロードマップ

## 🚀 Cursorの進化の方向性

### 2025年の展望

1. **より高度な自律性**
   - プロジェクト全体の設計提案
   - アーキテクチャの最適化

2. **チーム協調機能**
   - リアルタイムコラボレーション
   - AIメンターモード

3. **カスタムエージェント**
   - 企業独自のAIエージェント作成
   - 業界特化型エージェント

### 💡 開発者の役割は「実装」から「設計」へ

<!--
説明者メモ：
- あくまで予定であり変更の可能性あり
- ユーザーフィードバックで優先順位が変わる
- 将来的にはAIが開発の主役になる可能性
-->

---

# 機能比較マトリクス

## 📊 主要AI開発ツールの比較

| 機能 | Cursor | Copilot | Claude | Devin |
|------|--------|---------|---------|--------|
| **統合環境** | ◎ | △ | × | × |
| **複数ファイル編集** | ◎ | × | △ | ◎ |
| **自律実行** | ◎ | × | × | ◎ |
| **プライバシー** | ◎ | ○ | ○ | △ |
| **価格** | ○ | ◎ | ○ | △ |
| **学習コスト** | ◎ | ◎ | ○ | × |

### 📌 総合的にCursorが最もバランスが良い

<!--
説明者メモ：
- ◎=優秀、○=良い、△=普通、×=非対応
- 用途によって最適なツールは異なる
- 組み合わせて使うのも有効
-->

---

# 自律性の段階

## 📈 AI開発ツールの進化

### 4段階の自律性レベル

1. **補完レベル**（Copilot）
   - コード補完のみ
   - 人間が主導

2. **対話レベル**（Claude Code）
   - 質問応答型
   - 段階的な実装

3. **実行レベル**（Cursor）👈 現在地
   - タスクの自動実行
   - 人間は監督役

4. **完全自律**（Devin）
   - 独立してプロジェクト完遂
   - 人間は要件定義のみ

<!--
説明者メモ：
- Cursorは「ちょうどいい」自律性
- 完全自律は魅力的だが、制御が難しい
- 段階的に自律性を上げていくのが現実的
-->

---

# 適材適所の使い分け

## 🎯 プロジェクト規模別の選択

### タスクサイズ別推奨ツール

| 規模 | 例 | 推奨ツール | 理由 |
|------|-----|-----------|------|
| **小規模** | 関数の実装 | Copilot | 高速で十分 |
| **中規模** | 機能追加 | **Cursor** | バランス良 |
| **大規模** | システム構築 | Cursor/Devin | 自律性必要 |

### 💡 併用もおすすめ
- 日常: Copilot
- 複雑なタスク: Cursor
- 実験的: Devin

<!--
説明者メモ：
- 無理に一つに絞る必要はない
- チームメンバーのスキルも考慮
- コストパフォーマンスも重要
-->

---

# 価格対効果の比較

## 💰 ROI分析

### 投資対効果の試算

| 項目 | 従来開発 | Cursor導入後 |
|------|----------|-------------|
| **開発時間** | 100時間 | 40時間（-60%） |
| **人件費** | 50万円 | 20万円 |
| **ツール費** | 0円 | 2千円 |
| **実質削減額** | - | 約30万円/月 |

### 📊 ROI = 15,000%
（30万円の削減 ÷ 2千円の投資）

### 💡 1人日の作業時間短縮で元が取れる

<!--
説明者メモ：
- 数字は一例（プロジェクトによる）
- 品質向上効果は含まれていない
- チーム全体では更に効果大
-->

---

# 移行の容易さ

## 🔄 スムーズな導入プロセス

### エディタ別の移行期間

| 現在の環境 | 移行期間 | 難易度 | 備考 |
|-----------|---------|--------|------|
| **VS Code** | 即日 | ★☆☆☆☆ | 拡張機能も互換 |
| **JetBrains** | 1週間 | ★★★☆☆ | キーマップ変更要 |
| **Vim/Emacs** | 2週間 | ★★★★☆ | 拡張で対応可 |
| **その他IDE** | 1-2週間 | ★★★☆☆ | 標準的 |

### 移行のコツ
1. 小さなプロジェクトから開始
2. チームで知見を共有
3. 段階的に高度な機能へ

<!--
説明者メモ：
- VS Codeユーザーは本当に簡単
- キーバインドはカスタマイズ可能
- 移行ガイドも充実している
-->

---

# awesome-cursorrulesの活用

## 🌟 コミュニティの知恵を活用

### awesome-cursorrulesとは
**コミュニティが作成したCursor用ルール集**

### 内容
- **言語別の最適化ルール**
  - Python, JavaScript, Go, Rust等
  
- **フレームワーク別設定**
  - React, Vue, Django, Rails等

- **ベストプラクティス集**
  - パフォーマンス最適化
  - セキュリティ強化

### 📍 github.com/PatrickJS/awesome-cursorrules

<!--
説明者メモ：
- スター数も多く、活発にメンテナンス
- 自分のルールも貢献可能
- まずは既存のルールを試すのがおすすめ
-->

---

# 効率的なプロンプト作成

## ✍️ AIを最大限活用するコツ

### プロンプトの基本原則

1. **具体的な指示を心がける**
   ```
   ❌ 「改善して」
   ✅ 「実行速度を50%向上させて」
   ```

2. **コンテキストを明確に**
   ```
   ❌ 「エラーを直して」
   ✅ 「ユーザーがログインできないエラーを修正」
   ```

3. **段階的なアプローチ**
   ```
   1. 問題の特定
   2. 解決策の提案
   3. 実装
   ```

<!--
説明者メモ：
- 良いプロンプト = 良い結果
- 最初は試行錯誤が必要
- テンプレート化すると効率的
-->

---

# よくある失敗と対策

## ⚠️ 初心者が陥りがちな罠

### 失敗パターンと解決策

| 失敗 | 原因 | 対策 |
|------|------|------|
| **曖昧な指示** | 具体性不足 | 例を提示 |
| **大きすぎるタスク** | 一度に多くを要求 | 分割して実行 |
| **レビュー不足** | 生成コードを盲信 | 必ず確認 |
| **コンテキスト不足** | @シンボル未使用 | 関連ファイル指定 |

### 💡 失敗は学習の機会
- フィードバックでAIも改善
- パターンを覚えて効率化

<!--
説明者メモ：
- 誰もが通る道なので恐れずに
- 小さく始めて徐々に大きく
- チームで失敗事例を共有すると良い
-->

---

# チーム導入のベストプラクティス

## 👥 組織での効果的な展開方法

### 段階的導入プロセス

1. **パイロットチームから開始**
   - 技術に前向きなチーム
   - 小規模プロジェクト
   - 2-4週間のトライアル

2. **成功事例を共有**
   - 定量的な効果測定
   - Before/Afterの比較
   - 課題と解決策

3. **段階的に展開**
   - 部署ごとに拡大
   - サポート体制構築
   - ルールの標準化

<!--
説明者メモ：
- 急激な全社導入は避ける
- 反対派も巻き込む工夫が必要
- 経営層への報告も重要
-->

---

# Cursorがもたらす変革

## 🌟 開発現場の未来

### 3つの大きな変化

1. **開発速度が2-3倍に**
   - 実装時間の大幅短縮
   - イテレーションの高速化

2. **エンジニアの創造性が向上**
   - ルーティンワークから解放
   - 設計・アーキテクチャに集中

3. **チーム全体の生産性アップ**
   - 知識共有の促進
   - 品質の標準化

### 💡 「作る」から「創る」へのシフト

<!--
説明者メモ：
- 単なる効率化ではなく、働き方の変革
- AIは脅威ではなく、強力なパートナー
- 早期導入が競争優位性につながる
-->

---

# 今日から始められること

## 🚀 最初の一歩

### 3つのアクションプラン

1. **無料プランで体験**
   - 2週間の無料トライアル
   - 主要機能はすべて使用可能
   - クレジットカード不要

2. **既存プロジェクトで試用**
   - 小さな機能追加から
   - バグ修正で効果実感
   - 徐々に高度な機能へ

3. **チームに共有**
   - 今日の内容をシェア
   - デモを実施
   - 一緒に学習

<!--
説明者メモ：
- まずは個人で試すのがおすすめ
- 無理に全機能を使う必要はない
- 小さな成功体験を積み重ねる
-->

---

# 次のステップ

## 📋 継続的な学習と導入

### 推奨アクション

1. **ハンズオンセッション参加**
   - 実践的なワークショップ
   - 質問しながら学習
   - 他の参加者との交流

2. **社内勉強会の開催**
   - チーム内で知識共有
   - カスタムルール作成
   - ベストプラクティス確立

3. **パイロット導入の検討**
   - ROI測定の計画
   - 成功指標の設定
   - フィードバック収集

<!--
説明者メモ：
- 継続的な学習が重要
- コミュニティも活用
- 定期的な振り返りを推奨
-->

---

# Q&Aセッション

## 🤝 ご質問をお受けします

### よくある質問
- セキュリティは大丈夫？
- 既存の開発フローとの統合は？
- どのくらいで習熟できる？

### 💬 実演リクエストも歓迎
- 特定の機能のデモ
- 実際のコード例
- トラブルシューティング

### 📝 フィードバック歓迎
- 導入の障壁
- 追加で知りたいこと
- 改善提案

<!--
説明者メモ：
- 時間が許す限り対応
- 答えられない質問は後日回答
- 実演は事前に準備しておく
-->

---

# 補足A1: AIモデル詳細比較表

## 🤖 各モデルの詳細スペック

| モデル | コンテキスト長 | 応答速度 | 得意分野 | 料金 |
|--------|--------------|----------|----------|------|
| **GPT-4o** | 128K | 中速 | 汎用・推論 | 高 |
| **GPT-3.5** | 16K | 高速 | 基本タスク | 低 |
| **Claude 3.5** | 200K | 中速 | コード理解 | 中 |
| **Gemini 2.0** | 1M | 高速 | 最新技術 | 中 |

### 選択の指針
- **速度重視**: GPT-3.5 or Gemini
- **品質重視**: GPT-4o or Claude
- **コスト重視**: GPT-3.5

<!--
説明者メモ：
- コンテキスト長 = 一度に扱える情報量
- プロジェクトサイズで選択
- 切り替えは簡単なので、試すのが一番
-->

---

# 補足A2: Privacy Mode技術仕様

## 🔐 セキュリティアーキテクチャ

### 技術仕様
- **処理場所**: ローカルマシン内
- **通信**: 一切の外部通信なし
- **データ保存**: メモリ内のみ
- **暗号化**: AES-256

### パフォーマンス影響
- CPU使用率: +20-30%
- メモリ使用量: +2-4GB
- 応答速度: 通常の70%程度

### 推奨スペック
- CPU: 8コア以上
- RAM: 16GB以上
- SSD: 推奨

<!--
説明者メモ：
- 機密プロジェクトでは必須
- 若干遅いが、セキュリティ優先
- オンプレミス版も計画中
-->

---

# 補足A3: Rules設定の実例集

## 📝 実践的なルール例

### Python プロジェクト
```json
{
  "rules": [
    "Use type hints for all functions",
    "Follow PEP 8 style guide",
    "Prefer list comprehensions",
    "Add docstrings to all public methods"
  ]
}
```

### React プロジェクト
```json
{
  "rules": [
    "Use functional components only",
    "Implement custom hooks for logic",
    "Use TypeScript for all files",
    "Follow Airbnb style guide"
  ]
}
```

<!--
説明者メモ：
- プロジェクト開始時に設定
- チーム全員で合意形成
- 定期的な見直しも重要
-->

---

# 補足A4: トラブルシューティング

## 🔧 よくある問題と解決法

| 問題 | 原因 | 解決方法 |
|------|------|----------|
| **遅い応答** | 大きなコンテキスト | @シンボルで範囲限定 |
| **的外れな提案** | 情報不足 | より具体的な指示 |
| **エラー多発** | モデル設定 | 別モデルを試す |
| **同期エラー** | ネットワーク | オフラインモード |

### 💡 サポート窓口
- 公式Discord
- GitHubイシュー
- サポートメール

<!--
説明者メモ：
- 大抵の問題は設定で解決
- コミュニティが親切で活発
- アップデートで改善されることも多い
-->

---

# 補足A5: 移行チェックリスト

## ✅ スムーズな移行のために

### 事前準備
- [ ] VS Code拡張機能のリスト作成
- [ ] キーボードショートカットの確認
- [ ] .gitignoreの更新（.cursorを追加）
- [ ] チームメンバーへの周知

### 初期設定
- [ ] Cursorのインストール
- [ ] 拡張機能の移行
- [ ] プロジェクトルールの設定
- [ ] AIモデルの選択

### 運用開始
- [ ] 小さなタスクで練習
- [ ] チームでの知見共有
- [ ] 定期的な振り返り

<!--
説明者メモ：
- チェックリストは配布可能
- 1つずつ確実に進める
- 焦らず段階的に移行
-->

---

# ありがとうございました

## 🚀 Cursorで新しい開発体験を！

### 本日の資料
- スライド: 共有リンクから
- デモコード: GitHubリポジトリ
- 追加情報: 公式ドキュメント

### コンタクト
- Email: [your-email]
- Discord: [discord-id]
- Twitter: [@your-handle]

### 💡 Let's build the future together!

<!--
説明者メモ：
- 質問は後日でも受付
- フォローアップを忘れずに
- コミュニティへの参加を促す
-->