---
marp: true
theme: gaia
header: "AI駆動開発勉強会 Women's Base"
footer: "2025.07.05"
---

# Cursor勉強会

---

# 目次

1. **イントロダクション**（5分）
2. **Cursorの基本概要**（10分）
3. **よく使う主要機能**（15分）
4. **Cursor 1.0の新機能**（10分）
5. **他のAI IDEとの比較**（5分）
6. **実務での活用Tips**（5分）

---

# 1. イントロダクション

---

## 1-1. Cursorとは？

### 🎯 **ポイント**
**AI駆動型の統合開発環境（IDE）**

### 📝 **詳細説明**
- Visual Studio Codeをフォークして開発
- AIが深く統合された開発環境
- コードベース全体を理解し、自然言語で対話可能

### 💡 **補足**
- 2023年に登場し、急速に人気を獲得
- 開発元：Anysphere社
- 月間アクティブユーザー数が急増中

---

## 1-2. なぜCursorが注目されているのか

### 🎯 **3つの革新**

#### 1. **開発効率の劇的な向上**
- コード生成速度が10倍以上に
- デバッグ時間を50%削減

#### 2. **「思考の速度でコーディング」**
- アイデアから実装までのギャップを最小化
- 自然言語で指示するだけ

#### 3. **グラントワークからの解放**
- 繰り返し作業の自動化
- より創造的な作業に集中可能

### 💡 **補足**
実際のユーザーレポートでは、「1日の作業が2-3時間で終わるようになった」という声も

---

## 1-3. 本日のゴール

### 🎯 **3つの目標**

1. **Cursorの主要機能を理解する**
   - 実際に使える機能を習得
   - ショートカットキーを覚える

2. **実務での活用イメージを持つ**
   - 具体的な使用シーンを理解
   - 効率的なワークフローを構築

3. **他のAI IDEとの違いを理解する**
   - 適材適所でツールを選択
   - チームでの導入判断材料を得る

---

# 2. Cursorの基本概要

---

## 2-1. Cursorの特徴とポジショニング

### 🎯 **AIファーストな設計**

#### **コードベース全体の理解**
- プロジェクト構造を完全に把握
- ファイル間の依存関係を認識
- 過去の変更履歴も考慮

#### **自然言語での指示**
```text
例：「ユーザー認証機能を追加して」
    「このAPIのレスポンス時間を改善して」
    「TypeScriptに移行して」
```

#### **複雑なタスクの自動実行**
- マルチファイル編集
- リファクタリング
- テスト生成

### 💡 **補足**
従来のIDEは「ツール」でしたが、Cursorは「パートナー」として機能します

---

## 2-2. VS Codeベースの利点

### 🎯 **学習コストゼロ**

#### **即座に使い始められる理由**

1. **使い慣れたインターフェース**
   - ショートカットキーが同じ
   - レイアウトも同一
   - 設定の移行も簡単

2. **拡張機能の互換性**
   - 既存の拡張機能がそのまま使える
   - VS Code Marketplaceに対応
   - チーム環境の移行も容易

3. **ゼロ学習コスト**
   - VS Codeユーザーなら即日活用可能
   - 新しいUIを覚える必要なし
   - AIの恩恵をすぐに享受

### 💡 **補足**
実際の移行時間：平均15分以内で完全移行可能

---

## 2-3. 活用事例の紹介

### 🎯 **事例1: Netflix風アプリの実装**

#### **実装内容**
- **UIコンポーネント**
  - ヘッダー、カルーセル、カード
  - レスポンシブデザイン対応

- **機能実装**
  - 動画の検索・フィルタリング
  - お気に入り機能
  - 視聴履歴管理

#### **所要時間**
- 従来：2-3日
- Cursor使用：2-3時間

### 💡 **ハンズオンでの実践**
本日のハンズオンでVibe Codingを使って実際に体験します

---

### 🎯 **事例2: ダークモードの追加**

#### **一言の指示で実現**
```text
「アプリにダークモードを追加して」
```

#### **自動実行される内容**
1. **テーマ状態管理の実装**
   - Context APIまたはReduxでの状態管理
   - LocalStorageでの設定保存

2. **UIコンポーネントの更新**
   - 全コンポーネントのテーマ対応
   - トグルボタンの追加

3. **スタイルの生成**
   - CSS変数の定義
   - ダーク/ライトテーマの色定義

### 💡 **補足**
実際のプロジェクトでは、デザインシステムに合わせたカスタマイズも可能

---

### 🎯 **事例3: バグ修正とリファクタリング**

#### **エラーの原因特定**
```text
「このエラーの原因を特定して修正して」
```
- スタックトレースの分析
- 関連コードの特定
- 修正案の提示と実装

#### **コードの最適化**
```text
「このAPIのパフォーマンスを改善して」
```
- ボトルネックの特定
- キャッシュ戦略の実装
- クエリの最適化

### 💡 **実績データ**
- バグ修正時間：平均70%削減
- パフォーマンス改善：平均2-3倍の高速化

---

# 3. よく使う主要機能

---

## 3-1. Tab補完（スーパーコンプリート）

### 🎯 **特徴：次世代の自動補完**

#### **複数行の編集・修正を提案**
- 単なる単語補完ではない
- 文脈を理解した複数行の提案
- コードパターンの学習と適用

#### **視覚的フィードバック**
- **灰色のゴーストテキスト**：追加される内容
- **差分表示**：変更される内容を右側に表示
- **即座に確認可能**：変更内容が一目瞭然

### 📝 **使用例**

```python
# 例1: 関数シグネチャの変更
def process_data(data):  # カーソルをここに置いて編集開始
    threshold = 0.5
    # 処理...

# ↓ Tab補完が提案
def process_data(data, config):  # configパラメータを追加
    threshold = config.get_threshold()  # 自動的に変更
    # 処理...
```

### 🔥 **Pro Tips**
- **Tab連打テクニック**：関連する変更を連鎖的に適用
- **Ctrl/⌘ →**：単語単位で部分的に受け入れ
- **Esc**：提案を拒否

### 💡 **補足**
独自のAIモデルにより、プロジェクト固有のコーディングスタイルも学習

---

## 3-2. Ctrl+K（インライン編集）

### 🎯 **特徴：思考を中断しない編集**

#### **3つのモード**
1. **選択範囲の編集**：既存コードの改善
2. **新規コード生成**：ゼロから作成
3. **全ファイル編集**：⌘⇧⏎で広範囲変更

### 📝 **実践例**

#### **例1: 関数の最適化**
```javascript
// 既存のコード（選択してCtrl+K）
function calculateSum(numbers) {
    let sum = 0;
    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i];
    }
    return sum;
}

// プロンプト：「この関数を最新のJS構文で最適化して」

// 結果
const calculateSum = (numbers) => numbers.reduce((sum, num) => sum + num, 0);
```

#### **例2: ターミナルでの自然言語コマンド**
```bash
# Ctrl+Kで入力
"すべてのJSファイルでconsole.logを検索"

# 生成されるコマンド
grep -r "console\.log" --include="*.js" .
```

### 🔥 **効率化のコツ**
- 具体的な指示を与える
- 小さな変更から始める
- 生成結果を必ず確認

---

## 3-3. チャット機能（Cmd+L）

### 🎯 **特徴：プロジェクト全体を理解するAI**

#### **コンテキスト認識**
- 開いているファイル
- カーソル位置
- プロジェクト構造
- Git履歴

### 📝 **活用シーン**

#### **1. コード理解**
```text
Q: 「UserServiceクラスの責務を説明して」
A: UserServiceは以下の責務を持ちます：
   - ユーザー認証（authenticate メソッド）
   - プロフィール管理（updateProfile メソッド）
   - 権限チェック（hasPermission メソッド）
```

#### **2. バグ特定**
```text
Q: 「このエラーメッセージの原因は？」
   TypeError: Cannot read property 'id' of undefined
   
A: エラーはline 45で発生しています。
   user オブジェクトがundefinedの可能性があります。
   修正案：
   if (user && user.id) { ... }
```

### 🔥 **チャット活用術**
- エラーメッセージをそのまま貼り付け
- 具体的なコード箇所を指定
- 段階的に質問を深める

---

## 3-4. @シンボルによるコンテキスト管理

### 🎯 **特徴：AIに正確な文脈を提供**

#### **主要な@シンボル一覧**

| シンボル | 用途 | 使用例 |
|---------|------|--------|
| @ファイル | 特定ファイルを参照 | `@api/users.js このファイルにCRUD操作を追加` |
| @フォルダ | ディレクトリ全体を参照 | `@components 全コンポーネントをTypeScript化` |
| @Web | 最新情報を検索 | `@Web Next.js 14の新機能` |
| @Docs | ドキュメント参照 | `@Docs React Hook Form の使い方` |
| @Git | Git履歴を参照 | `@Git 最近の変更で壊れた可能性のある箇所` |
| @Terminal | ターミナル出力を参照 | `@Terminal このエラーの解決方法` |

### 📝 **実践的な使用例**

```text
# 複数のコンテキストを組み合わせ
@models/User.js @controllers/UserController.js 
これらのファイルを参考に、ユーザー削除機能を実装して

# Web検索と組み合わせ
@Web Prisma ORM best practices
@schema.prisma このスキーマを最適化して
```

### 🔥 **コンテキスト管理のベストプラクティス**
1. **必要最小限のコンテキスト**：関連ファイルのみ指定
2. **明確な指示**：何を参考に何をしたいか明確に
3. **段階的な追加**：最初は少なく、必要に応じて追加

### 💡 **補足**
v0.50以降、@フォルダで大規模なディレクトリも効率的に扱えるように

---

# 4. Cursor 1.0の新機能

---

## 4-1. Agent機能（Ctrl+I）- 自律的なコーディングパートナー

### 🎯 **特徴：エンドツーエンドのタスク実行**

#### **自律的な動作**
1. **計画立案**：タスクを分解し、実行計画を作成
2. **ファイル探索**：必要なファイルを自動で特定
3. **コード生成・編集**：複数ファイルを同時編集
4. **コマンド実行**：ビルド、テスト、デプロイ

### 📝 **実践例：ダークモード実装**

```text
指示：「アプリにダークモードのトグルを追加して」
```

#### **Agentが実行する内容**

```typescript
// 1. テーマコンテキストの作成
// contexts/ThemeContext.tsx
export const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () => {}
});

// 2. テーマプロバイダーの実装
// providers/ThemeProvider.tsx
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  // LocalStorage連携も自動実装
};

// 3. 各コンポーネントの更新
// components/Header.tsx
const Header = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  // ダークモード対応のスタイル適用
};

// 4. CSS変数の定義
// styles/themes.css
:root {
  --bg-color: #ffffff;
  --text-color: #000000;
}
[data-theme="dark"] {
  --bg-color: #1a1a1a;
  --text-color: #ffffff;
}
```

### 🔥 **YOLOモード**
- **自動テスト実行**：テストが通るまで修正を繰り返す
- **Lintエラー解決**：すべてのエラーを自動修正
- **完全自律モード**：人間の介入なしで完了

### 💡 **使い分けのコツ**
- **Agent使用**：複雑な機能追加、大規模リファクタリング
- **Ctrl+K使用**：小規模な修正、単一ファイルの変更

---

## 4-2. BugBot - AIレビュアー

### 🎯 **特徴：プルリクエストの自動レビュー**

#### **動作フロー**
1. GitHub PRが作成/更新される
2. BugBotが自動的にコードを分析
3. 潜在的な問題をコメント
4. 「Fix in Cursor」ボタンで即座に修正

### 📝 **検出される問題の例**

```javascript
// BugBotが検出するコード
function processUser(user) {
  // 🐛 BugBot: user が null/undefined の場合のチェックがありません
  const name = user.name.toUpperCase();
  
  // 🐛 BugBot: 配列が空の場合の処理が不足
  const firstRole = user.roles[0];
  
  return { name, firstRole };
}
```

### 🔥 **活用方法**
- **自動実行**：PR作成時に自動で動作
- **手動実行**：`bugbot run`をPRにコメント
- **ワンクリック修正**：提案された修正を即座に適用

### 💡 **補足**
内部テストでは、人間のレビュアーが見逃した微妙なバグも検出

---

## 4-3. バックグラウンドエージェント

### 🎯 **特徴：並行作業で生産性向上**

#### **非同期実行の利点**
- メインの作業を中断しない
- 複数のタスクを同時進行
- クラウド環境で実行

### 📝 **実用例**

#### **例1: 大規模ドキュメント生成**
```text
バックグラウンドタスク：
「全ファイルにJSDocコメントを追加して、
 各ファイルの役割、依存関係、
 リファクタリング候補を記載」
```

#### **例2: テストカバレッジ向上**
```text
バックグラウンドタスク：
「テストカバレッジ80%を目指して、
 不足しているテストケースを生成」
```

### 🔥 **効果的な使い方**
1. **長時間タスクの委任**：30分以上かかる作業
2. **定期的なメンテナンス**：コード品質チェック
3. **並行開発**：機能開発とリファクタリングを同時進行

---

## 4-4. メモリー機能（ベータ）

### 🎯 **特徴：AIが過去の会話を記憶**

#### **記憶される内容**
- プロジェクト固有のルール
- 過去の決定事項
- よく使うコマンドやパターン

### 📝 **実践例**

```text
# 初回の指示
「Shadcnコンポーネントをインストールする時は、
 npx shadcn-ui@latest add ではなく
 pnpm dlx shadcn-ui@latest add を使って」

# 2週間後
「Buttonコンポーネントをインストールして」
→ AIが自動的に pnpm dlx を使用
```

### 🔥 **メモリー活用術**
1. **プロジェクトルールの登録**
2. **チーム固有の慣習を記憶**
3. **頻繁に使うスニペットの保存**

### 💡 **注意点**
- プライバシーモード有効時は使用不可
- プロジェクトごとに独立して保存

---

## 4-5. その他の注目機能

### 🎯 **Jupyter Notebook連携**

```python
# データサイエンスワークフロー
# CursorがJupyterセルを直接編集

# セル1: データ読み込み
df = pd.read_csv('data.csv')

# セル2: EDA（AIが自動生成）
df.describe()
df.info()
plt.figure(figsize=(10, 6))
# 可視化コードも自動生成

# セル3: モデル構築
model = RandomForestClassifier()
# ハイパーパラメータチューニングも提案
```

### 🎯 **リッチなチャット応答**

```mermaid
# システムアーキテクチャ図を自動生成
graph LR
    A[Frontend] --> B[API Gateway]
    B --> C[Auth Service]
    B --> D[User Service]
    D --> E[(Database)]
```

---

# 5. 他のAI IDEとの比較

---

## 5-1. 機能比較表

### 🎯 **主要AI IDE比較**

| 機能 | Cursor | GitHub Copilot | Claude Code | Cline | Devin |
|------|--------|----------------|-------------|--------|--------|
| **基本機能** |
| コード補完 | ◎ 複数行対応 | ○ 単行中心 | ○ | ○ | △ |
| インライン編集 | ◎ | △ | ○ | ○ | × |
| チャット機能 | ◎ | ○ | ◎ | ○ | ○ |
| **高度な機能** |
| コードベース理解 | ◎ 全体把握 | △ ファイル単位 | ○ | ○ | ◎ |
| 自律的タスク実行 | ◎ Agent | × | △ | ○ | ◎ |
| 複数ファイル編集 | ◎ 同時編集 | △ | ○ | ○ | ◎ |
| バックグラウンド実行 | ◎ | × | × | × | ○ |
| **統合性** |
| IDE統合 | ◎ ネイティブ | ○ 拡張機能 | △ | △ | × |
| Git連携 | ◎ BugBot | ○ | △ | △ | ○ |

### 💡 **選択の指針**
- **Cursor**：総合的な開発効率を求める場合
- **Copilot**：既存のワークフローを維持したい場合
- **Claude Code**：対話的な開発を好む場合

---

## 5-2. 自走度合いの比較

### 🎯 **AIの自律性レベル**

```
低 ← ─────────────────────────── → 高
     Copilot   Claude   Cline   Cursor   Devin
      (補完)   (対話)  (半自律) (自律)  (完全自律)
```

#### **各ツールの特徴**

**GitHub Copilot**
- 人間主導、AI補助
- 一行ずつの提案
- 手動での適用が必要

**Claude Code**
- 対話ベースの開発
- 段階的な実装
- 人間の確認が都度必要

**Cursor**
- 高レベル指示で自律実行
- 複雑なタスクも一度に処理
- 必要に応じて人間が介入

**Devin**
- 完全自律型
- 独立した環境で実行
- 結果のみ確認

---

## 5-3. 適したタスクサイズ

### 🎯 **タスクサイズ別の最適ツール**

#### **小規模タスク（5-30分）**
```text
例：単一関数の実装、バグ修正
推奨：Copilot、Claude Code

理由：
- 素早い補完で十分
- 過度な自動化は不要
- 細かい制御が可能
```

#### **中規模タスク（30分-2時間）**
```text
例：新機能追加、複数ファイルのリファクタリング
推奨：Cursor、Cline

理由：
- 複数ファイルの同時編集
- 適度な自律性
- 効率と制御のバランス
```

#### **大規模タスク（2時間以上）**
```text
例：アーキテクチャ変更、大規模マイグレーション
推奨：Cursor（Agent）、Devin

理由：
- 完全な自律実行
- バックグラウンド処理
- 複雑な依存関係の処理
```

### 💡 **使い分けの実例**
```text
朝：Cursorで新機能の実装（Agent使用）
昼：Copilotで細かいバグ修正
夕：Cursorのバックグラウンドでテスト生成
```

---

# 6. 実務での活用Tips

---

## 6-1. Cursor Rulesの設定

### 🎯 **3種類のルール**

#### **1. プロジェクトルール**
```markdown
# .cursor/rules/frontend.mdc
- すべてのReactコンポーネントは関数型で記述
- カスタムフックは use プレフィックスを使用
- スタイリングはTailwind CSSを使用
- 状態管理はZustandを使用
```

#### **2. ユーザールール**
```markdown
# グローバル設定
- 日本語でコメントを記述
- エラーハンドリングは必ず実装
- console.logは本番環境で削除
```

#### **3. メモリー（自動生成）**
- 過去の会話から自動的に学習
- プロジェクト固有の決定事項を記憶

### 🔥 **効果的なルール例**

```markdown
# .cursor/rules/api.mdc
## APIエンドポイントのルール
- RESTful設計に準拠
- エラーレスポンスは統一フォーマット
  {
    "error": {
      "code": "ERROR_CODE",
      "message": "Human readable message"
    }
  }
- 認証はJWT使用
- レート制限を実装
```

---

## 6-2. 効率的なワークフロー

### 🎯 **段階的開発アプローチ**

#### **Step 1: 基本構造**
```text
Ctrl+I: 「UserManagerコンポーネントの基本構造を作成」
→ 骨組みだけ生成
```

#### **Step 2: 機能追加**
```text
Ctrl+K: 各機能を個別に実装
- ユーザー一覧表示
- 検索機能
- ソート機能
```

#### **Step 3: 最適化**
```text
Tab補完: パフォーマンス改善
チャット: 「このコンポーネントの最適化ポイントは？」
```

### 🔥 **並行作業の活用**

```text
メインタスク：新機能開発（Ctrl+I）
バックグラウンド：
- テスト生成
- ドキュメント更新
- コード品質チェック
```

---

## 6-3. 注意点とベストプラクティス

### ⚠️ **注意すべきポイント**

#### **1. AIの提案を盲信しない**
- 生成されたコードは必ずレビュー
- セキュリティの観点でチェック
- ビジネスロジックの妥当性確認

#### **2. パフォーマンスの考慮**
- 大規模ファイル（1万行以上）では遅延あり
- 複雑なプロジェクトでは段階的に適用

#### **3. コスト管理**
- レートリミットを意識
- Max Modeは必要時のみ使用
- 使用量をモニタリング

### ✅ **ベストプラクティス**

#### **1. 明確なプロンプト**
```text
❌ 悪い例：「改善して」
✅ 良い例：「このAPIのレスポンス時間を
         N+1問題を解決して改善して」
```

#### **2. コンテキストの最適化**
```text
❌ 悪い例：@src（全ソースコード）
✅ 良い例：@models/User.js @api/users.js
```

#### **3. 段階的な実装**
- 小さく始めて徐々に拡張
- 各段階で動作確認
- 問題があれば即座に修正

### 💡 **チーム導入のコツ**
1. **パイロットプロジェクトから開始**
2. **成功事例を共有**
3. **ルールとガイドラインを整備**
4. **定期的な振り返り**

---

# まとめ

### 🎯 **Cursorがもたらす変革**

1. **開発速度の飛躍的向上**
   - 2-10倍の生産性向上
   - 「思考の速度」での実装

2. **開発者の役割の変化**
   - コーダー → アーキテクト
   - 実装者 → 指揮者

3. **より創造的な仕事へ**
   - グラントワークからの解放
   - 問題解決に集中

### 🚀 **次のステップ**

1. **今日のハンズオン**
   - Netflix風アプリをVibe Codingで実装
   - 実際の開発フローを体験

2. **明日から始められること**
   - 小さなタスクから試す
   - チームメンバーと知見を共有

3. **継続的な学習**
   - 新機能のキャッチアップ
   - ベストプラクティスの更新

### 💬 **最後に**

Cursorは単なるツールではなく、開発の未来を体現しています。
AIと協働することで、より価値の高い仕事に集中できる時代が来ています。

**今日から、あなたも「AIペアプログラマー」と一緒に開発を始めてみませんか？**

---

# 付録：ショートカット一覧

| 機能 | Mac | Windows/Linux |
|------|-----|---------------|
| Tab補完 | Tab | Tab |
| インライン編集 | ⌘K | Ctrl+K |
| 全ファイル編集 | ⌘⇧⏎ | Ctrl+Shift+Enter |
| Agent起動 | ⌘I | Ctrl+I |
| チャット開閉 | ⌘L | Ctrl+L |
| 部分的に受け入れ | ⌘→ | Ctrl+→ |

---

# 参考リソース

- Cursor公式ドキュメント
- コミュニティフォーラム
- YouTube チュートリアル
- 社内ナレッジベース（随時更新）